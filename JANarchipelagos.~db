rem ------------------------------------------
rem Monthly Remake Project 2026 : JANUARY
rem Archipelagos
rem JLMOONDOG - Josh Mooney
rem ------------------------------------------

rem setup screen -----------------------------
rem ------------------------------------------
`set window on : set window layout 1, 1, 1
set display mode 1024, 768, 32
`windowTitle$ = "MRP2026: Archipelagos"
`set window title windowTitle$
hide mouse
autocam off
sync rate 0: sync on : sync rate 60

rem declare variables ------------------------
rem ------------------------------------------
rem system variables
debug = 1 : `debug menu on/off
errorMessage$ = "Error Code" : `01=loading
rem map variables
dim mapLines$(1000) : `for reading map files
lineCount = 0 : `# of lines in map file
readMap$ = "" : `var to read map file line
mapLoadMode = 1 : `0=off 1=int map 2=heightmap
mapWidth = 0 : `map terrain size
mapHeight = 0
tileSize = 15.0
`map tile types
WATER_LEVEL = 0
SAND_LEVEL = 1
GRASS_LEVEL = 2
dim heightMap(64,64) : `heightmap array
rem obelisk var / model 5
obeliskX# = 0.0
obeliskZ# = 0.0
obeliskMode = 0 : `0=destroyed 1=meltdown 2=active
rem nodes var
nodesCount = 0
dim nodes(100)
dim nodesMode(100) : `0=destroyed 1=notconnected 2=connected+active
   `models 101-200
rem player variables
playerStartX# = 0.0
playerStartZ# = 0.0
MOUSE_SENS# = 0.15
CAM_PITCH# = 0.0
CAM_YAW# = 0.0
SMOOTHING# = 0.35  : ` 0 = raw, 1 = very smooth (0.25–0.4 sweet spot)
smoothMX# = 0
smoothMY# = 0

rem load map ---------------------------------
rem ------------------------------------------
mapFile$ = "maps/testmap.map"
if file exist(mapFile$) = 0 : `check for map file
   exit prompt errorMessage$+" 01", mapFile$
   end
endif

open to read 1, mapFile$ : `read map file & store in array
   while file end(1) = 0
      inc lineCount
      read string 1, readMap$
      mapLines$(lineCount) = UPPER$(TRIM$(readMap$))
   endwhile
close file 1

for m = 1 to lineCount : `step through mapLines
   c$ = LEFT$(mapLines$(m),2)
   if mapLoadMode = 2
      for my = 1 to mapHeight
         heightMap$ = mapLines$(m)
         inc m, 1
         for mx = 1 to mapWidth
            grabHeight$ = MID$(heightMap$,mx)
            heightMap(mx,my)=VAL(grabHeight$)+1
         next mx
      next my
      mapLoadMode = 0
   endif
   if mapLoadMode = 1
   select c$
      case "SZ" : `map size
         grabe$ = RIGHT$(mapLines$(m),4)
         mapWidth = VAL(LEFT$(grabe$,2))
         mapHeight = VAL(RIGHT$(grabe$,2))
      endcase
      case "ST" : `player start location
         grabe$ = RIGHT$(mapLines$(m),4)
         playerStartX# = (VAL(LEFT$(grabe$,2)))*tileSize
         playerStartZ# = (VAL(RIGHT$(grabe$,2)))*tileSize
         position camera playerStartX#, 5.0, playerStartZ#
      endcase
      case "OB" : `obelisk location
         grabe$ = RIGHT$(mapLines$(m),4)
         obeliskX# = (VAL(LEFT$(grabe$,2)))*tileSize
         obeliskZ# = (VAL(RIGHT$(grabe$,2)))*tileSize
         obeliskMode = 2
         make object cube 5, 8
         position object 5, obeliskX#, 16.0, obeliskZ#
         color object 5, RGB(200,50,50)
         scale object 5, 100, 400, 100
      endcase
      case "ND" : `node and location
         inc nodesCount, 1
         nodes(nodesCount) = nodesCount+100
         nodesMode(nodesCount) = 2
         make object cube nodes(nodesCount), 4
         grabe$ = RIGHT$(mapLines$(m),4)
         nodeX# = (VAL(LEFT$(grabe$,2)))*tileSize
         nodeZ# = (VAL(RIGHT$(grabe$,2)))*tileSize
         position object nodes(nodesCount), nodeX#, 2.0, nodeZ#
         color object nodes(nodesCount), RGB(50,200,200)
      endcase
      case "MP" : `switch map Load Mode
         mapLoadMode = 2
      endcase
   endselect
   endif
next m

rem create terrain ---------------------------
matrixsizeX#=mapWidth*tileSize
matrixsizeZ#=mapHeight*tileSize
matrixGridX#=mapWidth
matrixGridZ#=mapHeight
make matrix 1, matrixsizeX#, matrixsizeZ#, matrixgridX#, matrixgridZ#
position matrix 1, 0-(tileSize/2), 0, 0-(tileSize/2)
load image "media/maptexture.bmp",1
prepare matrix texture 1,1,2,2
`texture island
for tx = 0 to mapWidth-1
   for ty = 0 to mapHeight-1
      set matrix tile 1, tx, ty, heightMap(tx+1,ty+1)
   next ty
next tx
update matrix 1

rem setup enviroment -------------------------
rem ------------------------------------------
fog on : fog color 0
fog distance 750
backdrop on : color backdrop 0
set ambient light 35
color ambient light rgb(255,255,255)
set camera range 5, 1000
cls

rem main game loop ---------------------------
rem ------------------------------------------
do
rem debug menu -------------------------------
rem ------------------------------------------
if debug = 1
   set cursor 0,0
   print "  ** DEBUG MENU **"
   print "  First MAPLINE: ";mapLines$(1)
   print "  FPS:";screen fps()
   print "  nodes: ";nodesCount
   print "  obX: ";obeliskX#
   print "  obZ: ";obeliskZ#
   print "  HPX: ";heightMap(1,1)
   print "  HPX: ";heightMap(5,5)
   print "  HMG: ";heightMap$
   print "  GHM: ";grabHeight$
endif

rem mouse look -------------------------------
rem ------------------------------------------
OLD_CAM_PITCH# = CAM_PITCH#

rawMX# = mousemovex()
rawMY# = mousemovey()

smoothMX# = smoothMX# + (rawMX# - smoothMX#) * SMOOTHING#
smoothMY# = smoothMY# + (rawMY# - smoothMY#) * SMOOTHING#

CAM_YAW#   = wrapvalue(CAM_YAW# + smoothMX# * MOUSE_SENS#)
CAM_PITCH# = wrapvalue(CAM_PITCH# + smoothMY# * MOUSE_SENS#)

` Clamp pitch (no flipping)
if CAM_PITCH# > 85 and CAM_PITCH# < 180 then CAM_PITCH# = 85
if CAM_PITCH# >= 180 and CAM_PITCH# < 275 then CAM_PITCH# = 275

rotate camera CAM_PITCH#, CAM_YAW#, 0

   sync
loop

rem functions --------------------------------
rem ------------------------------------------
FUNCTION TRIM$( s$ )

    ` Remove leading spaces and tabs
    WHILE LEN(s$) > 0
        c$ = LEFT$(s$,1)
        IF c$ <> " " AND c$ <> CHR$(9) THEN EXIT
        s$ = MID$(s$,2)
    ENDWHILE

    ` Remove trailing spaces and tabs
    WHILE LEN(s$) > 0
        c$ = RIGHT$(s$,1)
        IF c$ <> " " AND c$ <> CHR$(9) THEN EXIT
        s$ = LEFT$(s$,LEN(s$)-1)
    ENDWHILE

    returnTrim$ = s$

ENDFUNCTION returnTrim$
